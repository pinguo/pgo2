// Code generated by MockGen. DO NOT EDIT.
// Source: adapter/interface.go

// Package mock_adapter is a generated GoMock package.
package mock_adapter

import (
	context "context"
	sql "database/sql"
	mgo "github.com/globalsign/mgo"
	bson "github.com/globalsign/mgo/bson"
	gomock "github.com/golang/mock/gomock"
	adapter "github.com/pinguo/pgo2/adapter"
	maxmind "github.com/pinguo/pgo2/client/maxmind"
	memcache "github.com/pinguo/pgo2/client/memcache"
	phttp "github.com/pinguo/pgo2/client/phttp"
	rabbitmq "github.com/pinguo/pgo2/client/rabbitmq"
	iface "github.com/pinguo/pgo2/iface"
	value "github.com/pinguo/pgo2/value"
	amqp "github.com/streadway/amqp"
	http "net/http"
	reflect "reflect"
	time "time"
)

// MockIMemory is a mock of IMemory interface
type MockIMemory struct {
	ctrl     *gomock.Controller
	recorder *MockIMemoryMockRecorder
}

// MockIMemoryMockRecorder is the mock recorder for MockIMemory
type MockIMemoryMockRecorder struct {
	mock *MockIMemory
}

// NewMockIMemory creates a new mock instance
func NewMockIMemory(ctrl *gomock.Controller) *MockIMemory {
	mock := &MockIMemory{ctrl: ctrl}
	mock.recorder = &MockIMemoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIMemory) EXPECT() *MockIMemoryMockRecorder {
	return m.recorder
}

// SetPanicRecover mocks base method
func (m *MockIMemory) SetPanicRecover(v bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPanicRecover", v)
}

// SetPanicRecover indicates an expected call of SetPanicRecover
func (mr *MockIMemoryMockRecorder) SetPanicRecover(v interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPanicRecover", reflect.TypeOf((*MockIMemory)(nil).SetPanicRecover), v)
}

// Get mocks base method
func (m *MockIMemory) Get(key string) *value.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].(*value.Value)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockIMemoryMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIMemory)(nil).Get), key)
}

// MGet mocks base method
func (m *MockIMemory) MGet(keys []string) map[string]*value.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MGet", keys)
	ret0, _ := ret[0].(map[string]*value.Value)
	return ret0
}

// MGet indicates an expected call of MGet
func (mr *MockIMemoryMockRecorder) MGet(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockIMemory)(nil).MGet), keys)
}

// Set mocks base method
func (m *MockIMemory) Set(key string, value interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, value}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Set", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Set indicates an expected call of Set
func (mr *MockIMemoryMockRecorder) Set(key, value interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, value}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockIMemory)(nil).Set), varargs...)
}

// MSet mocks base method
func (m *MockIMemory) MSet(items map[string]interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSet", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MSet indicates an expected call of MSet
func (mr *MockIMemoryMockRecorder) MSet(items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockIMemory)(nil).MSet), varargs...)
}

// Add mocks base method
func (m *MockIMemory) Add(key string, value interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, value}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Add", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Add indicates an expected call of Add
func (mr *MockIMemoryMockRecorder) Add(key, value interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, value}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIMemory)(nil).Add), varargs...)
}

// MAdd mocks base method
func (m *MockIMemory) MAdd(items map[string]interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MAdd", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MAdd indicates an expected call of MAdd
func (mr *MockIMemoryMockRecorder) MAdd(items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MAdd", reflect.TypeOf((*MockIMemory)(nil).MAdd), varargs...)
}

// Del mocks base method
func (m *MockIMemory) Del(key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Del", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Del indicates an expected call of Del
func (mr *MockIMemoryMockRecorder) Del(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockIMemory)(nil).Del), key)
}

// MDel mocks base method
func (m *MockIMemory) MDel(keys []string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MDel", keys)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MDel indicates an expected call of MDel
func (mr *MockIMemoryMockRecorder) MDel(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MDel", reflect.TypeOf((*MockIMemory)(nil).MDel), keys)
}

// Exists mocks base method
func (m *MockIMemory) Exists(key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists
func (mr *MockIMemoryMockRecorder) Exists(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockIMemory)(nil).Exists), key)
}

// Incr mocks base method
func (m *MockIMemory) Incr(key string, delta int) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Incr", key, delta)
	ret0, _ := ret[0].(int)
	return ret0
}

// Incr indicates an expected call of Incr
func (mr *MockIMemoryMockRecorder) Incr(key, delta interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockIMemory)(nil).Incr), key, delta)
}

// MockIHttp is a mock of IHttp interface
type MockIHttp struct {
	ctrl     *gomock.Controller
	recorder *MockIHttpMockRecorder
}

// MockIHttpMockRecorder is the mock recorder for MockIHttp
type MockIHttpMockRecorder struct {
	mock *MockIHttp
}

// NewMockIHttp creates a new mock instance
func NewMockIHttp(ctrl *gomock.Controller) *MockIHttp {
	mock := &MockIHttp{ctrl: ctrl}
	mock.recorder = &MockIHttpMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIHttp) EXPECT() *MockIHttpMockRecorder {
	return m.recorder
}

// SetPanicRecover mocks base method
func (m *MockIHttp) SetPanicRecover(v bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPanicRecover", v)
}

// SetPanicRecover indicates an expected call of SetPanicRecover
func (mr *MockIHttpMockRecorder) SetPanicRecover(v interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPanicRecover", reflect.TypeOf((*MockIHttp)(nil).SetPanicRecover), v)
}

// Get mocks base method
func (m *MockIHttp) Get(addr string, data interface{}, option ...*phttp.Option) *http.Response {
	m.ctrl.T.Helper()
	varargs := []interface{}{addr, data}
	for _, a := range option {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*http.Response)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockIHttpMockRecorder) Get(addr, data interface{}, option ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{addr, data}, option...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIHttp)(nil).Get), varargs...)
}

// Post mocks base method
func (m *MockIHttp) Post(addr string, data interface{}, option ...*phttp.Option) *http.Response {
	m.ctrl.T.Helper()
	varargs := []interface{}{addr, data}
	for _, a := range option {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Post", varargs...)
	ret0, _ := ret[0].(*http.Response)
	return ret0
}

// Post indicates an expected call of Post
func (mr *MockIHttpMockRecorder) Post(addr, data interface{}, option ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{addr, data}, option...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Post", reflect.TypeOf((*MockIHttp)(nil).Post), varargs...)
}

// Do mocks base method
func (m *MockIHttp) Do(req *http.Request, option ...*phttp.Option) *http.Response {
	m.ctrl.T.Helper()
	varargs := []interface{}{req}
	for _, a := range option {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Do", varargs...)
	ret0, _ := ret[0].(*http.Response)
	return ret0
}

// Do indicates an expected call of Do
func (mr *MockIHttpMockRecorder) Do(req interface{}, option ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{req}, option...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockIHttp)(nil).Do), varargs...)
}

// DoMulti mocks base method
func (m *MockIHttp) DoMulti(requests []*http.Request, option ...*phttp.Option) []*http.Response {
	m.ctrl.T.Helper()
	varargs := []interface{}{requests}
	for _, a := range option {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DoMulti", varargs...)
	ret0, _ := ret[0].([]*http.Response)
	return ret0
}

// DoMulti indicates an expected call of DoMulti
func (mr *MockIHttpMockRecorder) DoMulti(requests interface{}, option ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{requests}, option...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoMulti", reflect.TypeOf((*MockIHttp)(nil).DoMulti), varargs...)
}

// MockIMaxMind is a mock of IMaxMind interface
type MockIMaxMind struct {
	ctrl     *gomock.Controller
	recorder *MockIMaxMindMockRecorder
}

// MockIMaxMindMockRecorder is the mock recorder for MockIMaxMind
type MockIMaxMindMockRecorder struct {
	mock *MockIMaxMind
}

// NewMockIMaxMind creates a new mock instance
func NewMockIMaxMind(ctrl *gomock.Controller) *MockIMaxMind {
	mock := &MockIMaxMind{ctrl: ctrl}
	mock.recorder = &MockIMaxMindMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIMaxMind) EXPECT() *MockIMaxMindMockRecorder {
	return m.recorder
}

// GeoByIp mocks base method
func (m *MockIMaxMind) GeoByIp(ip string, args ...interface{}) *maxmind.Geo {
	m.ctrl.T.Helper()
	varargs := []interface{}{ip}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GeoByIp", varargs...)
	ret0, _ := ret[0].(*maxmind.Geo)
	return ret0
}

// GeoByIp indicates an expected call of GeoByIp
func (mr *MockIMaxMindMockRecorder) GeoByIp(ip interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ip}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoByIp", reflect.TypeOf((*MockIMaxMind)(nil).GeoByIp), varargs...)
}

// MockIMemCache is a mock of IMemCache interface
type MockIMemCache struct {
	ctrl     *gomock.Controller
	recorder *MockIMemCacheMockRecorder
}

// MockIMemCacheMockRecorder is the mock recorder for MockIMemCache
type MockIMemCacheMockRecorder struct {
	mock *MockIMemCache
}

// NewMockIMemCache creates a new mock instance
func NewMockIMemCache(ctrl *gomock.Controller) *MockIMemCache {
	mock := &MockIMemCache{ctrl: ctrl}
	mock.recorder = &MockIMemCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIMemCache) EXPECT() *MockIMemCacheMockRecorder {
	return m.recorder
}

// SetPanicRecover mocks base method
func (m *MockIMemCache) SetPanicRecover(v bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPanicRecover", v)
}

// SetPanicRecover indicates an expected call of SetPanicRecover
func (mr *MockIMemCacheMockRecorder) SetPanicRecover(v interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPanicRecover", reflect.TypeOf((*MockIMemCache)(nil).SetPanicRecover), v)
}

// Get mocks base method
func (m *MockIMemCache) Get(key string) *value.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].(*value.Value)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockIMemCacheMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIMemCache)(nil).Get), key)
}

// MGet mocks base method
func (m *MockIMemCache) MGet(keys []string) map[string]*value.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MGet", keys)
	ret0, _ := ret[0].(map[string]*value.Value)
	return ret0
}

// MGet indicates an expected call of MGet
func (mr *MockIMemCacheMockRecorder) MGet(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockIMemCache)(nil).MGet), keys)
}

// Set mocks base method
func (m *MockIMemCache) Set(key string, value interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, value}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Set", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Set indicates an expected call of Set
func (mr *MockIMemCacheMockRecorder) Set(key, value interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, value}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockIMemCache)(nil).Set), varargs...)
}

// MSet mocks base method
func (m *MockIMemCache) MSet(items map[string]interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSet", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MSet indicates an expected call of MSet
func (mr *MockIMemCacheMockRecorder) MSet(items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockIMemCache)(nil).MSet), varargs...)
}

// Add mocks base method
func (m *MockIMemCache) Add(key string, value interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, value}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Add", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Add indicates an expected call of Add
func (mr *MockIMemCacheMockRecorder) Add(key, value interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, value}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIMemCache)(nil).Add), varargs...)
}

// MAdd mocks base method
func (m *MockIMemCache) MAdd(items map[string]interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MAdd", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MAdd indicates an expected call of MAdd
func (mr *MockIMemCacheMockRecorder) MAdd(items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MAdd", reflect.TypeOf((*MockIMemCache)(nil).MAdd), varargs...)
}

// Del mocks base method
func (m *MockIMemCache) Del(key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Del", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Del indicates an expected call of Del
func (mr *MockIMemCacheMockRecorder) Del(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockIMemCache)(nil).Del), key)
}

// MDel mocks base method
func (m *MockIMemCache) MDel(keys []string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MDel", keys)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MDel indicates an expected call of MDel
func (mr *MockIMemCacheMockRecorder) MDel(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MDel", reflect.TypeOf((*MockIMemCache)(nil).MDel), keys)
}

// Exists mocks base method
func (m *MockIMemCache) Exists(key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists
func (mr *MockIMemCacheMockRecorder) Exists(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockIMemCache)(nil).Exists), key)
}

// Incr mocks base method
func (m *MockIMemCache) Incr(key string, delta int) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Incr", key, delta)
	ret0, _ := ret[0].(int)
	return ret0
}

// Incr indicates an expected call of Incr
func (mr *MockIMemCacheMockRecorder) Incr(key, delta interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockIMemCache)(nil).Incr), key, delta)
}

// Retrieve mocks base method
func (m *MockIMemCache) Retrieve(cmd, key string) *memcache.Item {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Retrieve", cmd, key)
	ret0, _ := ret[0].(*memcache.Item)
	return ret0
}

// Retrieve indicates an expected call of Retrieve
func (mr *MockIMemCacheMockRecorder) Retrieve(cmd, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Retrieve", reflect.TypeOf((*MockIMemCache)(nil).Retrieve), cmd, key)
}

// MultiRetrieve mocks base method
func (m *MockIMemCache) MultiRetrieve(cmd string, keys []string) []*memcache.Item {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MultiRetrieve", cmd, keys)
	ret0, _ := ret[0].([]*memcache.Item)
	return ret0
}

// MultiRetrieve indicates an expected call of MultiRetrieve
func (mr *MockIMemCacheMockRecorder) MultiRetrieve(cmd, keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiRetrieve", reflect.TypeOf((*MockIMemCache)(nil).MultiRetrieve), cmd, keys)
}

// Store mocks base method
func (m *MockIMemCache) Store(cmd string, item *memcache.Item, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{cmd, item}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Store", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Store indicates an expected call of Store
func (mr *MockIMemCacheMockRecorder) Store(cmd, item interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{cmd, item}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockIMemCache)(nil).Store), varargs...)
}

// MultiStore mocks base method
func (m *MockIMemCache) MultiStore(cmd string, items []*memcache.Item, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{cmd, items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MultiStore", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MultiStore indicates an expected call of MultiStore
func (mr *MockIMemCacheMockRecorder) MultiStore(cmd, items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{cmd, items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MultiStore", reflect.TypeOf((*MockIMemCache)(nil).MultiStore), varargs...)
}

// MockIMongo is a mock of IMongo interface
type MockIMongo struct {
	ctrl     *gomock.Controller
	recorder *MockIMongoMockRecorder
}

// MockIMongoMockRecorder is the mock recorder for MockIMongo
type MockIMongoMockRecorder struct {
	mock *MockIMongo
}

// NewMockIMongo creates a new mock instance
func NewMockIMongo(ctrl *gomock.Controller) *MockIMongo {
	mock := &MockIMongo{ctrl: ctrl}
	mock.recorder = &MockIMongoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIMongo) EXPECT() *MockIMongoMockRecorder {
	return m.recorder
}

// FindOne mocks base method
func (m *MockIMongo) FindOne(query, result interface{}, options ...bson.M) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{query, result}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindOne", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindOne indicates an expected call of FindOne
func (mr *MockIMongoMockRecorder) FindOne(query, result interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query, result}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockIMongo)(nil).FindOne), varargs...)
}

// FindAll mocks base method
func (m *MockIMongo) FindAll(query, result interface{}, options ...bson.M) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{query, result}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAll", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindAll indicates an expected call of FindAll
func (mr *MockIMongoMockRecorder) FindAll(query, result interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query, result}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockIMongo)(nil).FindAll), varargs...)
}

// FindAndModify mocks base method
func (m *MockIMongo) FindAndModify(query interface{}, change mgo.Change, result interface{}, options ...bson.M) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{query, change, result}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAndModify", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindAndModify indicates an expected call of FindAndModify
func (mr *MockIMongoMockRecorder) FindAndModify(query, change, result interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query, change, result}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAndModify", reflect.TypeOf((*MockIMongo)(nil).FindAndModify), varargs...)
}

// FindDistinct mocks base method
func (m *MockIMongo) FindDistinct(query interface{}, key string, result interface{}, options ...bson.M) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{query, key, result}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindDistinct", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindDistinct indicates an expected call of FindDistinct
func (mr *MockIMongoMockRecorder) FindDistinct(query, key, result interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query, key, result}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindDistinct", reflect.TypeOf((*MockIMongo)(nil).FindDistinct), varargs...)
}

// InsertOne mocks base method
func (m *MockIMongo) InsertOne(doc interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertOne", doc)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertOne indicates an expected call of InsertOne
func (mr *MockIMongoMockRecorder) InsertOne(doc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockIMongo)(nil).InsertOne), doc)
}

// InsertAll mocks base method
func (m *MockIMongo) InsertAll(docs []interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertAll", docs)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertAll indicates an expected call of InsertAll
func (mr *MockIMongoMockRecorder) InsertAll(docs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertAll", reflect.TypeOf((*MockIMongo)(nil).InsertAll), docs)
}

// UpdateOne mocks base method
func (m *MockIMongo) UpdateOne(query, update interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateOne", query, update)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateOne indicates an expected call of UpdateOne
func (mr *MockIMongoMockRecorder) UpdateOne(query, update interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockIMongo)(nil).UpdateOne), query, update)
}

// UpdateAll mocks base method
func (m *MockIMongo) UpdateAll(query, update interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateAll", query, update)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAll indicates an expected call of UpdateAll
func (mr *MockIMongoMockRecorder) UpdateAll(query, update interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAll", reflect.TypeOf((*MockIMongo)(nil).UpdateAll), query, update)
}

// UpdateOrInsert mocks base method
func (m *MockIMongo) UpdateOrInsert(query, update interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateOrInsert", query, update)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateOrInsert indicates an expected call of UpdateOrInsert
func (mr *MockIMongoMockRecorder) UpdateOrInsert(query, update interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrInsert", reflect.TypeOf((*MockIMongo)(nil).UpdateOrInsert), query, update)
}

// DeleteOne mocks base method
func (m *MockIMongo) DeleteOne(query interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteOne", query)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteOne indicates an expected call of DeleteOne
func (mr *MockIMongoMockRecorder) DeleteOne(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockIMongo)(nil).DeleteOne), query)
}

// DeleteAll mocks base method
func (m *MockIMongo) DeleteAll(query interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAll", query)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAll indicates an expected call of DeleteAll
func (mr *MockIMongoMockRecorder) DeleteAll(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAll", reflect.TypeOf((*MockIMongo)(nil).DeleteAll), query)
}

// Count mocks base method
func (m *MockIMongo) Count(query interface{}, options ...bson.M) (int, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Count", varargs...)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count
func (mr *MockIMongoMockRecorder) Count(query interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockIMongo)(nil).Count), varargs...)
}

// PipeOne mocks base method
func (m *MockIMongo) PipeOne(pipeline, result interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PipeOne", pipeline, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// PipeOne indicates an expected call of PipeOne
func (mr *MockIMongoMockRecorder) PipeOne(pipeline, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PipeOne", reflect.TypeOf((*MockIMongo)(nil).PipeOne), pipeline, result)
}

// PipeAll mocks base method
func (m *MockIMongo) PipeAll(pipeline, result interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PipeAll", pipeline, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// PipeAll indicates an expected call of PipeAll
func (mr *MockIMongoMockRecorder) PipeAll(pipeline, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PipeAll", reflect.TypeOf((*MockIMongo)(nil).PipeAll), pipeline, result)
}

// MapReduce mocks base method
func (m *MockIMongo) MapReduce(query interface{}, job *mgo.MapReduce, result interface{}, options ...bson.M) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{query, job, result}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MapReduce", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// MapReduce indicates an expected call of MapReduce
func (mr *MockIMongoMockRecorder) MapReduce(query, job, result interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query, job, result}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapReduce", reflect.TypeOf((*MockIMongo)(nil).MapReduce), varargs...)
}

// MockIRedis is a mock of IRedis interface
type MockIRedis struct {
	ctrl     *gomock.Controller
	recorder *MockIRedisMockRecorder
}

// MockIRedisMockRecorder is the mock recorder for MockIRedis
type MockIRedisMockRecorder struct {
	mock *MockIRedis
}

// NewMockIRedis creates a new mock instance
func NewMockIRedis(ctrl *gomock.Controller) *MockIRedis {
	mock := &MockIRedis{ctrl: ctrl}
	mock.recorder = &MockIRedisMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIRedis) EXPECT() *MockIRedisMockRecorder {
	return m.recorder
}

// SetPanicRecover mocks base method
func (m *MockIRedis) SetPanicRecover(v bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPanicRecover", v)
}

// SetPanicRecover indicates an expected call of SetPanicRecover
func (mr *MockIRedisMockRecorder) SetPanicRecover(v interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPanicRecover", reflect.TypeOf((*MockIRedis)(nil).SetPanicRecover), v)
}

// Get mocks base method
func (m *MockIRedis) Get(key string) *value.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].(*value.Value)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockIRedisMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockIRedis)(nil).Get), key)
}

// MGet mocks base method
func (m *MockIRedis) MGet(keys []string) map[string]*value.Value {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MGet", keys)
	ret0, _ := ret[0].(map[string]*value.Value)
	return ret0
}

// MGet indicates an expected call of MGet
func (mr *MockIRedisMockRecorder) MGet(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockIRedis)(nil).MGet), keys)
}

// Set mocks base method
func (m *MockIRedis) Set(key string, value interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, value}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Set", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Set indicates an expected call of Set
func (mr *MockIRedisMockRecorder) Set(key, value interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, value}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockIRedis)(nil).Set), varargs...)
}

// MSet mocks base method
func (m *MockIRedis) MSet(items map[string]interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSet", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MSet indicates an expected call of MSet
func (mr *MockIRedisMockRecorder) MSet(items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockIRedis)(nil).MSet), varargs...)
}

// Add mocks base method
func (m *MockIRedis) Add(key string, value interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{key, value}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Add", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Add indicates an expected call of Add
func (mr *MockIRedisMockRecorder) Add(key, value interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{key, value}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIRedis)(nil).Add), varargs...)
}

// MAdd mocks base method
func (m *MockIRedis) MAdd(items map[string]interface{}, expire ...time.Duration) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{items}
	for _, a := range expire {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MAdd", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MAdd indicates an expected call of MAdd
func (mr *MockIRedisMockRecorder) MAdd(items interface{}, expire ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{items}, expire...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MAdd", reflect.TypeOf((*MockIRedis)(nil).MAdd), varargs...)
}

// Del mocks base method
func (m *MockIRedis) Del(key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Del", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Del indicates an expected call of Del
func (mr *MockIRedisMockRecorder) Del(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockIRedis)(nil).Del), key)
}

// MDel mocks base method
func (m *MockIRedis) MDel(keys []string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MDel", keys)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MDel indicates an expected call of MDel
func (mr *MockIRedisMockRecorder) MDel(keys interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MDel", reflect.TypeOf((*MockIRedis)(nil).MDel), keys)
}

// Exists mocks base method
func (m *MockIRedis) Exists(key string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists
func (mr *MockIRedisMockRecorder) Exists(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockIRedis)(nil).Exists), key)
}

// Incr mocks base method
func (m *MockIRedis) Incr(key string, delta int) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Incr", key, delta)
	ret0, _ := ret[0].(int)
	return ret0
}

// Incr indicates an expected call of Incr
func (mr *MockIRedisMockRecorder) Incr(key, delta interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockIRedis)(nil).Incr), key, delta)
}

// Do mocks base method
func (m *MockIRedis) Do(cmd string, args ...interface{}) interface{} {
	m.ctrl.T.Helper()
	varargs := []interface{}{cmd}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Do", varargs...)
	ret0, _ := ret[0].(interface{})
	return ret0
}

// Do indicates an expected call of Do
func (mr *MockIRedisMockRecorder) Do(cmd interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{cmd}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockIRedis)(nil).Do), varargs...)
}

// MockIRabbitMq is a mock of IRabbitMq interface
type MockIRabbitMq struct {
	ctrl     *gomock.Controller
	recorder *MockIRabbitMqMockRecorder
}

// MockIRabbitMqMockRecorder is the mock recorder for MockIRabbitMq
type MockIRabbitMqMockRecorder struct {
	mock *MockIRabbitMq
}

// NewMockIRabbitMq creates a new mock instance
func NewMockIRabbitMq(ctrl *gomock.Controller) *MockIRabbitMq {
	mock := &MockIRabbitMq{ctrl: ctrl}
	mock.recorder = &MockIRabbitMqMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIRabbitMq) EXPECT() *MockIRabbitMqMockRecorder {
	return m.recorder
}

// SetPanicRecover mocks base method
func (m *MockIRabbitMq) SetPanicRecover(v bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPanicRecover", v)
}

// SetPanicRecover indicates an expected call of SetPanicRecover
func (mr *MockIRabbitMqMockRecorder) SetPanicRecover(v interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPanicRecover", reflect.TypeOf((*MockIRabbitMq)(nil).SetPanicRecover), v)
}

// ExchangeDeclare mocks base method
func (m *MockIRabbitMq) ExchangeDeclare() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ExchangeDeclare")
}

// ExchangeDeclare indicates an expected call of ExchangeDeclare
func (mr *MockIRabbitMqMockRecorder) ExchangeDeclare() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExchangeDeclare", reflect.TypeOf((*MockIRabbitMq)(nil).ExchangeDeclare))
}

// Publish mocks base method
func (m *MockIRabbitMq) Publish(opCode string, data interface{}, dftOpUid ...string) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{opCode, data}
	for _, a := range dftOpUid {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockIRabbitMqMockRecorder) Publish(opCode, data interface{}, dftOpUid ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{opCode, data}, dftOpUid...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockIRabbitMq)(nil).Publish), varargs...)
}

// GetConsumeChannelBox mocks base method
func (m *MockIRabbitMq) GetConsumeChannelBox(queueName string, opCodes []string) *rabbitmq.ChannelBox {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConsumeChannelBox", queueName, opCodes)
	ret0, _ := ret[0].(*rabbitmq.ChannelBox)
	return ret0
}

// GetConsumeChannelBox indicates an expected call of GetConsumeChannelBox
func (mr *MockIRabbitMqMockRecorder) GetConsumeChannelBox(queueName, opCodes interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConsumeChannelBox", reflect.TypeOf((*MockIRabbitMq)(nil).GetConsumeChannelBox), queueName, opCodes)
}

// Consume mocks base method
func (m *MockIRabbitMq) Consume(queueName string, opCodes []string, limit int, autoAck, noWait, exclusive bool) <-chan amqp.Delivery {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consume", queueName, opCodes, limit, autoAck, noWait, exclusive)
	ret0, _ := ret[0].(<-chan amqp.Delivery)
	return ret0
}

// Consume indicates an expected call of Consume
func (mr *MockIRabbitMqMockRecorder) Consume(queueName, opCodes, limit, autoAck, noWait, exclusive interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockIRabbitMq)(nil).Consume), queueName, opCodes, limit, autoAck, noWait, exclusive)
}

// DecodeBody mocks base method
func (m *MockIRabbitMq) DecodeBody(d amqp.Delivery, ret interface{}) error {
	m.ctrl.T.Helper()
	ret_2 := m.ctrl.Call(m, "DecodeBody", d, ret)
	ret0, _ := ret_2[0].(error)
	return ret0
}

// DecodeBody indicates an expected call of DecodeBody
func (mr *MockIRabbitMqMockRecorder) DecodeBody(d, ret interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DecodeBody", reflect.TypeOf((*MockIRabbitMq)(nil).DecodeBody), d, ret)
}

// DecodeHeaders mocks base method
func (m *MockIRabbitMq) DecodeHeaders(d amqp.Delivery) *rabbitmq.RabbitHeaders {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DecodeHeaders", d)
	ret0, _ := ret[0].(*rabbitmq.RabbitHeaders)
	return ret0
}

// DecodeHeaders indicates an expected call of DecodeHeaders
func (mr *MockIRabbitMqMockRecorder) DecodeHeaders(d interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DecodeHeaders", reflect.TypeOf((*MockIRabbitMq)(nil).DecodeHeaders), d)
}

// MockIDb is a mock of IDb interface
type MockIDb struct {
	ctrl     *gomock.Controller
	recorder *MockIDbMockRecorder
}

// MockIDbMockRecorder is the mock recorder for MockIDb
type MockIDbMockRecorder struct {
	mock *MockIDb
}

// NewMockIDb creates a new mock instance
func NewMockIDb(ctrl *gomock.Controller) *MockIDb {
	mock := &MockIDb{ctrl: ctrl}
	mock.recorder = &MockIDbMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIDb) EXPECT() *MockIDbMockRecorder {
	return m.recorder
}

// SetMaster mocks base method
func (m *MockIDb) SetMaster(v bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetMaster", v)
}

// SetMaster indicates an expected call of SetMaster
func (mr *MockIDbMockRecorder) SetMaster(v interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetMaster", reflect.TypeOf((*MockIDb)(nil).SetMaster), v)
}

// GetDb mocks base method
func (m *MockIDb) GetDb(master bool) *sql.DB {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDb", master)
	ret0, _ := ret[0].(*sql.DB)
	return ret0
}

// GetDb indicates an expected call of GetDb
func (mr *MockIDbMockRecorder) GetDb(master interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDb", reflect.TypeOf((*MockIDb)(nil).GetDb), master)
}

// Begin mocks base method
func (m *MockIDb) Begin(opts ...*sql.TxOptions) adapter.ITx {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Begin", varargs...)
	ret0, _ := ret[0].(adapter.ITx)
	return ret0
}

// Begin indicates an expected call of Begin
func (mr *MockIDbMockRecorder) Begin(opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockIDb)(nil).Begin), opts...)
}

// BeginContext mocks base method
func (m *MockIDb) BeginContext(ctx context.Context, opts *sql.TxOptions) adapter.ITx {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginContext", ctx, opts)
	ret0, _ := ret[0].(adapter.ITx)
	return ret0
}

// BeginContext indicates an expected call of BeginContext
func (mr *MockIDbMockRecorder) BeginContext(ctx, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginContext", reflect.TypeOf((*MockIDb)(nil).BeginContext), ctx, opts)
}

// QueryOne mocks base method
func (m *MockIDb) QueryOne(query string, args ...interface{}) adapter.IRow {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOne", varargs...)
	ret0, _ := ret[0].(adapter.IRow)
	return ret0
}

// QueryOne indicates an expected call of QueryOne
func (mr *MockIDbMockRecorder) QueryOne(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOne", reflect.TypeOf((*MockIDb)(nil).QueryOne), varargs...)
}

// QueryOneContext mocks base method
func (m *MockIDb) QueryOneContext(ctx context.Context, query string, args ...interface{}) adapter.IRow {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOneContext", varargs...)
	ret0, _ := ret[0].(adapter.IRow)
	return ret0
}

// QueryOneContext indicates an expected call of QueryOneContext
func (mr *MockIDbMockRecorder) QueryOneContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOneContext", reflect.TypeOf((*MockIDb)(nil).QueryOneContext), varargs...)
}

// Query mocks base method
func (m *MockIDb) Query(query string, args ...interface{}) *sql.Rows {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	return ret0
}

// Query indicates an expected call of Query
func (mr *MockIDbMockRecorder) Query(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIDb)(nil).Query), varargs...)
}

// QueryContext mocks base method
func (m *MockIDb) QueryContext(ctx context.Context, query string, args ...interface{}) *sql.Rows {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	return ret0
}

// QueryContext indicates an expected call of QueryContext
func (mr *MockIDbMockRecorder) QueryContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockIDb)(nil).QueryContext), varargs...)
}

// Exec mocks base method
func (m *MockIDb) Exec(query string, args ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// Exec indicates an expected call of Exec
func (mr *MockIDbMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIDb)(nil).Exec), varargs...)
}

// ExecContext mocks base method
func (m *MockIDb) ExecContext(ctx context.Context, query string, args ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// ExecContext indicates an expected call of ExecContext
func (mr *MockIDbMockRecorder) ExecContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockIDb)(nil).ExecContext), varargs...)
}

// Prepare mocks base method
func (m *MockIDb) Prepare(query string) adapter.IStmt {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", query)
	ret0, _ := ret[0].(adapter.IStmt)
	return ret0
}

// Prepare indicates an expected call of Prepare
func (mr *MockIDbMockRecorder) Prepare(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockIDb)(nil).Prepare), query)
}

// PrepareContext mocks base method
func (m *MockIDb) PrepareContext(ctx context.Context, query string) adapter.IStmt {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareContext", ctx, query)
	ret0, _ := ret[0].(adapter.IStmt)
	return ret0
}

// PrepareContext indicates an expected call of PrepareContext
func (mr *MockIDbMockRecorder) PrepareContext(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareContext", reflect.TypeOf((*MockIDb)(nil).PrepareContext), ctx, query)
}

// MockITx is a mock of ITx interface
type MockITx struct {
	ctrl     *gomock.Controller
	recorder *MockITxMockRecorder
}

// MockITxMockRecorder is the mock recorder for MockITx
type MockITxMockRecorder struct {
	mock *MockITx
}

// NewMockITx creates a new mock instance
func NewMockITx(ctrl *gomock.Controller) *MockITx {
	mock := &MockITx{ctrl: ctrl}
	mock.recorder = &MockITxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockITx) EXPECT() *MockITxMockRecorder {
	return m.recorder
}

// SetContext mocks base method
func (m *MockITx) SetContext(ctx iface.IContext) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetContext", ctx)
}

// SetContext indicates an expected call of SetContext
func (mr *MockITxMockRecorder) SetContext(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetContext", reflect.TypeOf((*MockITx)(nil).SetContext), ctx)
}

// Context mocks base method
func (m *MockITx) Context() iface.IContext {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Context")
	ret0, _ := ret[0].(iface.IContext)
	return ret0
}

// Context indicates an expected call of Context
func (mr *MockITxMockRecorder) Context() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Context", reflect.TypeOf((*MockITx)(nil).Context))
}

// GetObj mocks base method
func (m *MockITx) GetObj(obj iface.IObject) iface.IObject {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetObj", obj)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObj indicates an expected call of GetObj
func (mr *MockITxMockRecorder) GetObj(obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObj", reflect.TypeOf((*MockITx)(nil).GetObj), obj)
}

// GetObjPool mocks base method
func (m *MockITx) GetObjPool(funcName iface.IObjPoolFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjPool", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjPool indicates an expected call of GetObjPool
func (mr *MockITxMockRecorder) GetObjPool(funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjPool", reflect.TypeOf((*MockITx)(nil).GetObjPool), varargs...)
}

// GetObjSingle mocks base method
func (m *MockITx) GetObjSingle(name string, funcName iface.IObjSingleFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{name, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjSingle", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjSingle indicates an expected call of GetObjSingle
func (mr *MockITxMockRecorder) GetObjSingle(name, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjSingle", reflect.TypeOf((*MockITx)(nil).GetObjSingle), varargs...)
}

// GetObjPoolCtx mocks base method
func (m *MockITx) GetObjPoolCtx(ctr iface.IContext, funcName iface.IObjPoolFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctr, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjPoolCtx", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjPoolCtx indicates an expected call of GetObjPoolCtx
func (mr *MockITxMockRecorder) GetObjPoolCtx(ctr, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctr, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjPoolCtx", reflect.TypeOf((*MockITx)(nil).GetObjPoolCtx), varargs...)
}

// GetObjCtx mocks base method
func (m *MockITx) GetObjCtx(ctx iface.IContext, obj iface.IObject) iface.IObject {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetObjCtx", ctx, obj)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjCtx indicates an expected call of GetObjCtx
func (mr *MockITxMockRecorder) GetObjCtx(ctx, obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjCtx", reflect.TypeOf((*MockITx)(nil).GetObjCtx), ctx, obj)
}

// GetObjSingleCtx mocks base method
func (m *MockITx) GetObjSingleCtx(ctx iface.IContext, name string, funcName iface.IObjSingleFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, name, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjSingleCtx", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjSingleCtx indicates an expected call of GetObjSingleCtx
func (mr *MockITxMockRecorder) GetObjSingleCtx(ctx, name, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, name, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjSingleCtx", reflect.TypeOf((*MockITx)(nil).GetObjSingleCtx), varargs...)
}

// Commit mocks base method
func (m *MockITx) Commit() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Commit indicates an expected call of Commit
func (mr *MockITxMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockITx)(nil).Commit))
}

// Rollback mocks base method
func (m *MockITx) Rollback() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Rollback indicates an expected call of Rollback
func (mr *MockITxMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockITx)(nil).Rollback))
}

// QueryOne mocks base method
func (m *MockITx) QueryOne(query string, args ...interface{}) adapter.IRow {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOne", varargs...)
	ret0, _ := ret[0].(adapter.IRow)
	return ret0
}

// QueryOne indicates an expected call of QueryOne
func (mr *MockITxMockRecorder) QueryOne(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOne", reflect.TypeOf((*MockITx)(nil).QueryOne), varargs...)
}

// QueryOneContext mocks base method
func (m *MockITx) QueryOneContext(ctx context.Context, query string, args ...interface{}) adapter.IRow {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOneContext", varargs...)
	ret0, _ := ret[0].(adapter.IRow)
	return ret0
}

// QueryOneContext indicates an expected call of QueryOneContext
func (mr *MockITxMockRecorder) QueryOneContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOneContext", reflect.TypeOf((*MockITx)(nil).QueryOneContext), varargs...)
}

// Query mocks base method
func (m *MockITx) Query(query string, args ...interface{}) *sql.Rows {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	return ret0
}

// Query indicates an expected call of Query
func (mr *MockITxMockRecorder) Query(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockITx)(nil).Query), varargs...)
}

// QueryContext mocks base method
func (m *MockITx) QueryContext(ctx context.Context, query string, args ...interface{}) *sql.Rows {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	return ret0
}

// QueryContext indicates an expected call of QueryContext
func (mr *MockITxMockRecorder) QueryContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockITx)(nil).QueryContext), varargs...)
}

// Exec mocks base method
func (m *MockITx) Exec(query string, args ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// Exec indicates an expected call of Exec
func (mr *MockITxMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockITx)(nil).Exec), varargs...)
}

// ExecContext mocks base method
func (m *MockITx) ExecContext(ctx context.Context, query string, args ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// ExecContext indicates an expected call of ExecContext
func (mr *MockITxMockRecorder) ExecContext(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockITx)(nil).ExecContext), varargs...)
}

// Prepare mocks base method
func (m *MockITx) Prepare(query string) adapter.IStmt {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", query)
	ret0, _ := ret[0].(adapter.IStmt)
	return ret0
}

// Prepare indicates an expected call of Prepare
func (mr *MockITxMockRecorder) Prepare(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockITx)(nil).Prepare), query)
}

// PrepareContext mocks base method
func (m *MockITx) PrepareContext(ctx context.Context, query string) adapter.IStmt {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareContext", ctx, query)
	ret0, _ := ret[0].(adapter.IStmt)
	return ret0
}

// PrepareContext indicates an expected call of PrepareContext
func (mr *MockITxMockRecorder) PrepareContext(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareContext", reflect.TypeOf((*MockITx)(nil).PrepareContext), ctx, query)
}

// MockIRow is a mock of IRow interface
type MockIRow struct {
	ctrl     *gomock.Controller
	recorder *MockIRowMockRecorder
}

// MockIRowMockRecorder is the mock recorder for MockIRow
type MockIRowMockRecorder struct {
	mock *MockIRow
}

// NewMockIRow creates a new mock instance
func NewMockIRow(ctrl *gomock.Controller) *MockIRow {
	mock := &MockIRow{ctrl: ctrl}
	mock.recorder = &MockIRowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIRow) EXPECT() *MockIRowMockRecorder {
	return m.recorder
}

// SetContext mocks base method
func (m *MockIRow) SetContext(ctx iface.IContext) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetContext", ctx)
}

// SetContext indicates an expected call of SetContext
func (mr *MockIRowMockRecorder) SetContext(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetContext", reflect.TypeOf((*MockIRow)(nil).SetContext), ctx)
}

// Context mocks base method
func (m *MockIRow) Context() iface.IContext {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Context")
	ret0, _ := ret[0].(iface.IContext)
	return ret0
}

// Context indicates an expected call of Context
func (mr *MockIRowMockRecorder) Context() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Context", reflect.TypeOf((*MockIRow)(nil).Context))
}

// GetObj mocks base method
func (m *MockIRow) GetObj(obj iface.IObject) iface.IObject {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetObj", obj)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObj indicates an expected call of GetObj
func (mr *MockIRowMockRecorder) GetObj(obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObj", reflect.TypeOf((*MockIRow)(nil).GetObj), obj)
}

// GetObjPool mocks base method
func (m *MockIRow) GetObjPool(funcName iface.IObjPoolFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjPool", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjPool indicates an expected call of GetObjPool
func (mr *MockIRowMockRecorder) GetObjPool(funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjPool", reflect.TypeOf((*MockIRow)(nil).GetObjPool), varargs...)
}

// GetObjSingle mocks base method
func (m *MockIRow) GetObjSingle(name string, funcName iface.IObjSingleFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{name, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjSingle", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjSingle indicates an expected call of GetObjSingle
func (mr *MockIRowMockRecorder) GetObjSingle(name, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjSingle", reflect.TypeOf((*MockIRow)(nil).GetObjSingle), varargs...)
}

// GetObjPoolCtx mocks base method
func (m *MockIRow) GetObjPoolCtx(ctr iface.IContext, funcName iface.IObjPoolFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctr, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjPoolCtx", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjPoolCtx indicates an expected call of GetObjPoolCtx
func (mr *MockIRowMockRecorder) GetObjPoolCtx(ctr, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctr, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjPoolCtx", reflect.TypeOf((*MockIRow)(nil).GetObjPoolCtx), varargs...)
}

// GetObjCtx mocks base method
func (m *MockIRow) GetObjCtx(ctx iface.IContext, obj iface.IObject) iface.IObject {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetObjCtx", ctx, obj)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjCtx indicates an expected call of GetObjCtx
func (mr *MockIRowMockRecorder) GetObjCtx(ctx, obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjCtx", reflect.TypeOf((*MockIRow)(nil).GetObjCtx), ctx, obj)
}

// GetObjSingleCtx mocks base method
func (m *MockIRow) GetObjSingleCtx(ctx iface.IContext, name string, funcName iface.IObjSingleFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, name, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjSingleCtx", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjSingleCtx indicates an expected call of GetObjSingleCtx
func (mr *MockIRowMockRecorder) GetObjSingleCtx(ctx, name, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, name, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjSingleCtx", reflect.TypeOf((*MockIRow)(nil).GetObjSingleCtx), varargs...)
}

// Scan mocks base method
func (m *MockIRow) Scan(dest ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan
func (mr *MockIRowMockRecorder) Scan(dest ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIRow)(nil).Scan), dest...)
}

// MockIStmt is a mock of IStmt interface
type MockIStmt struct {
	ctrl     *gomock.Controller
	recorder *MockIStmtMockRecorder
}

// MockIStmtMockRecorder is the mock recorder for MockIStmt
type MockIStmtMockRecorder struct {
	mock *MockIStmt
}

// NewMockIStmt creates a new mock instance
func NewMockIStmt(ctrl *gomock.Controller) *MockIStmt {
	mock := &MockIStmt{ctrl: ctrl}
	mock.recorder = &MockIStmtMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIStmt) EXPECT() *MockIStmtMockRecorder {
	return m.recorder
}

// SetContext mocks base method
func (m *MockIStmt) SetContext(ctx iface.IContext) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetContext", ctx)
}

// SetContext indicates an expected call of SetContext
func (mr *MockIStmtMockRecorder) SetContext(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetContext", reflect.TypeOf((*MockIStmt)(nil).SetContext), ctx)
}

// Context mocks base method
func (m *MockIStmt) Context() iface.IContext {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Context")
	ret0, _ := ret[0].(iface.IContext)
	return ret0
}

// Context indicates an expected call of Context
func (mr *MockIStmtMockRecorder) Context() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Context", reflect.TypeOf((*MockIStmt)(nil).Context))
}

// GetObj mocks base method
func (m *MockIStmt) GetObj(obj iface.IObject) iface.IObject {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetObj", obj)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObj indicates an expected call of GetObj
func (mr *MockIStmtMockRecorder) GetObj(obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObj", reflect.TypeOf((*MockIStmt)(nil).GetObj), obj)
}

// GetObjPool mocks base method
func (m *MockIStmt) GetObjPool(funcName iface.IObjPoolFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjPool", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjPool indicates an expected call of GetObjPool
func (mr *MockIStmtMockRecorder) GetObjPool(funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjPool", reflect.TypeOf((*MockIStmt)(nil).GetObjPool), varargs...)
}

// GetObjSingle mocks base method
func (m *MockIStmt) GetObjSingle(name string, funcName iface.IObjSingleFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{name, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjSingle", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjSingle indicates an expected call of GetObjSingle
func (mr *MockIStmtMockRecorder) GetObjSingle(name, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjSingle", reflect.TypeOf((*MockIStmt)(nil).GetObjSingle), varargs...)
}

// GetObjPoolCtx mocks base method
func (m *MockIStmt) GetObjPoolCtx(ctr iface.IContext, funcName iface.IObjPoolFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctr, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjPoolCtx", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjPoolCtx indicates an expected call of GetObjPoolCtx
func (mr *MockIStmtMockRecorder) GetObjPoolCtx(ctr, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctr, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjPoolCtx", reflect.TypeOf((*MockIStmt)(nil).GetObjPoolCtx), varargs...)
}

// GetObjCtx mocks base method
func (m *MockIStmt) GetObjCtx(ctx iface.IContext, obj iface.IObject) iface.IObject {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetObjCtx", ctx, obj)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjCtx indicates an expected call of GetObjCtx
func (mr *MockIStmtMockRecorder) GetObjCtx(ctx, obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjCtx", reflect.TypeOf((*MockIStmt)(nil).GetObjCtx), ctx, obj)
}

// GetObjSingleCtx mocks base method
func (m *MockIStmt) GetObjSingleCtx(ctx iface.IContext, name string, funcName iface.IObjSingleFunc, params ...interface{}) iface.IObject {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, name, funcName}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetObjSingleCtx", varargs...)
	ret0, _ := ret[0].(iface.IObject)
	return ret0
}

// GetObjSingleCtx indicates an expected call of GetObjSingleCtx
func (mr *MockIStmtMockRecorder) GetObjSingleCtx(ctx, name, funcName interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, name, funcName}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetObjSingleCtx", reflect.TypeOf((*MockIStmt)(nil).GetObjSingleCtx), varargs...)
}

// Close mocks base method
func (m *MockIStmt) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close
func (mr *MockIStmtMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIStmt)(nil).Close))
}

// QueryOne mocks base method
func (m *MockIStmt) QueryOne(args ...interface{}) adapter.IRow {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOne", varargs...)
	ret0, _ := ret[0].(adapter.IRow)
	return ret0
}

// QueryOne indicates an expected call of QueryOne
func (mr *MockIStmtMockRecorder) QueryOne(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOne", reflect.TypeOf((*MockIStmt)(nil).QueryOne), args...)
}

// QueryOneContext mocks base method
func (m *MockIStmt) QueryOneContext(ctx context.Context, args ...interface{}) adapter.IRow {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOneContext", varargs...)
	ret0, _ := ret[0].(adapter.IRow)
	return ret0
}

// QueryOneContext indicates an expected call of QueryOneContext
func (mr *MockIStmtMockRecorder) QueryOneContext(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOneContext", reflect.TypeOf((*MockIStmt)(nil).QueryOneContext), varargs...)
}

// Query mocks base method
func (m *MockIStmt) Query(args ...interface{}) *sql.Rows {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	return ret0
}

// Query indicates an expected call of Query
func (mr *MockIStmtMockRecorder) Query(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIStmt)(nil).Query), args...)
}

// QueryContext mocks base method
func (m *MockIStmt) QueryContext(ctx context.Context, args ...interface{}) *sql.Rows {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryContext", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	return ret0
}

// QueryContext indicates an expected call of QueryContext
func (mr *MockIStmtMockRecorder) QueryContext(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryContext", reflect.TypeOf((*MockIStmt)(nil).QueryContext), varargs...)
}

// Exec mocks base method
func (m *MockIStmt) Exec(args ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// Exec indicates an expected call of Exec
func (mr *MockIStmtMockRecorder) Exec(args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIStmt)(nil).Exec), args...)
}

// ExecContext mocks base method
func (m *MockIStmt) ExecContext(ctx context.Context, args ...interface{}) sql.Result {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecContext", varargs...)
	ret0, _ := ret[0].(sql.Result)
	return ret0
}

// ExecContext indicates an expected call of ExecContext
func (mr *MockIStmtMockRecorder) ExecContext(ctx interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecContext", reflect.TypeOf((*MockIStmt)(nil).ExecContext), varargs...)
}
